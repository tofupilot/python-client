"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from pydantic import model_serializer
from tofupilot.v2.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from tofupilot.v2.utils import FieldMetadata, PathParamMetadata
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class UnitGetRequestTypedDict(TypedDict):
    serial_number: str
    r"""Serial number of the unit to retrieve."""


class UnitGetRequest(BaseModel):
    serial_number: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""Serial number of the unit to retrieve."""


class UnitGetCreatedByUserTypedDict(TypedDict):
    r"""User who created this unit."""

    id: str
    r"""User ID."""
    name: Nullable[str]
    r"""User display name."""


class UnitGetCreatedByUser(BaseModel):
    r"""User who created this unit."""

    id: str
    r"""User ID."""

    name: Nullable[str]
    r"""User display name."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetCreatedByStationTypedDict(TypedDict):
    r"""Station that created this unit."""

    id: str
    r"""Station ID."""
    name: str
    r"""Station name."""


class UnitGetCreatedByStation(BaseModel):
    r"""Station that created this unit."""

    id: str
    r"""Station ID."""

    name: str
    r"""Station name."""


class UnitGetRevisionTypedDict(TypedDict):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""


class UnitGetRevision(BaseModel):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""


class UnitGetPartTypedDict(TypedDict):
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: UnitGetRevisionTypedDict
    r"""Revision information for this unit."""


class UnitGetPart(BaseModel):
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: UnitGetRevision
    r"""Revision information for this unit."""


class UnitGetBatchTypedDict(TypedDict):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""
    number: str
    r"""Batch number."""


class UnitGetBatch(BaseModel):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""

    number: str
    r"""Batch number."""


class ParentRevisionTypedDict(TypedDict):
    r"""Part revision information."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""


class ParentRevision(BaseModel):
    r"""Part revision information."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""


class ParentPartTypedDict(TypedDict):
    r"""Part information for the parent unit."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: Nullable[ParentRevisionTypedDict]
    r"""Part revision information."""


class ParentPart(BaseModel):
    r"""Part information for the parent unit."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: Nullable[ParentRevision]
    r"""Part revision information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["revision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetParentTypedDict(TypedDict):
    r"""Parent unit information with part details and processed images."""

    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: Nullable[ParentPartTypedDict]
    r"""Part information for the parent unit."""


class UnitGetParent(BaseModel):
    r"""Parent unit information with part details and processed images."""

    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: Nullable[ParentPart]
    r"""Part information for the parent unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["part"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ChildRevisionTypedDict(TypedDict):
    r"""Part revision information."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""


class ChildRevision(BaseModel):
    r"""Part revision information."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""


class ChildPartTypedDict(TypedDict):
    r"""Part information for the child unit."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: Nullable[ChildRevisionTypedDict]
    r"""Part revision information."""


class ChildPart(BaseModel):
    r"""Part information for the child unit."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: Nullable[ChildRevision]
    r"""Part revision information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["revision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetChildTypedDict(TypedDict):
    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: Nullable[ChildPartTypedDict]
    r"""Part information for the child unit."""


class UnitGetChild(BaseModel):
    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: Nullable[ChildPart]
    r"""Part information for the child unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["part"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UnitGetOutcome = Literal["PASS", "FAIL", "ERROR", "TIMEOUT", "ABORTED"]
r"""Final result of the run execution."""


class UnitGetProcedureTypedDict(TypedDict):
    r"""Procedure information."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""


class UnitGetProcedure(BaseModel):
    r"""Procedure information."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""


class CreatedDuringTypedDict(TypedDict):
    r"""Run that created this unit."""

    id: str
    r"""Run ID."""
    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""
    started_at: datetime
    r"""ISO 8601 timestamp when the run started."""
    ended_at: datetime
    r"""ISO 8601 timestamp when the run ended."""
    duration: str
    r"""ISO 8601 duration of the run (computed from started_at and ended_at)."""
    outcome: UnitGetOutcome
    r"""Final result of the run execution."""
    procedure: UnitGetProcedureTypedDict
    r"""Procedure information."""


class CreatedDuring(BaseModel):
    r"""Run that created this unit."""

    id: str
    r"""Run ID."""

    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""

    started_at: datetime
    r"""ISO 8601 timestamp when the run started."""

    ended_at: datetime
    r"""ISO 8601 timestamp when the run ended."""

    duration: str
    r"""ISO 8601 duration of the run (computed from started_at and ended_at)."""

    outcome: UnitGetOutcome
    r"""Final result of the run execution."""

    procedure: UnitGetProcedure
    r"""Procedure information."""


class UnitGetAttachmentTypedDict(TypedDict):
    id: str
    r"""Attachment ID."""
    name: str
    r"""File name."""
    size: Nullable[float]
    r"""File size in bytes."""
    content_type: Nullable[str]
    r"""MIME type of the file."""
    download_url: Nullable[str]
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""


class UnitGetAttachment(BaseModel):
    id: str
    r"""Attachment ID."""

    name: str
    r"""File name."""

    size: Nullable[float]
    r"""File size in bytes."""

    content_type: Nullable[str]
    r"""MIME type of the file."""

    download_url: Nullable[str]
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["size", "content_type", "download_url"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetResponseTypedDict(TypedDict):
    r"""Units retrieved successfully"""

    id: str
    r"""Unique identifier for the unit."""
    serial_number: str
    r"""Unit serial number."""
    created_at: datetime
    r"""ISO 8601 timestamp when the unit was created."""
    part: UnitGetPartTypedDict
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""
    parent: Nullable[UnitGetParentTypedDict]
    r"""Parent unit information with part details and processed images."""
    created_by_user: NotRequired[Nullable[UnitGetCreatedByUserTypedDict]]
    r"""User who created this unit."""
    created_by_station: NotRequired[Nullable[UnitGetCreatedByStationTypedDict]]
    r"""Station that created this unit."""
    batch: NotRequired[Nullable[UnitGetBatchTypedDict]]
    r"""Batch information for this unit."""
    children: NotRequired[List[UnitGetChildTypedDict]]
    r"""Child units with part details."""
    created_during: NotRequired[Nullable[CreatedDuringTypedDict]]
    r"""Run that created this unit."""
    attachments: NotRequired[List[UnitGetAttachmentTypedDict]]
    r"""Files attached to this unit."""


class UnitGetResponse(BaseModel):
    r"""Units retrieved successfully"""

    id: str
    r"""Unique identifier for the unit."""

    serial_number: str
    r"""Unit serial number."""

    created_at: datetime
    r"""ISO 8601 timestamp when the unit was created."""

    part: UnitGetPart
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    parent: Nullable[UnitGetParent]
    r"""Parent unit information with part details and processed images."""

    created_by_user: OptionalNullable[UnitGetCreatedByUser] = UNSET
    r"""User who created this unit."""

    created_by_station: OptionalNullable[UnitGetCreatedByStation] = UNSET
    r"""Station that created this unit."""

    batch: OptionalNullable[UnitGetBatch] = UNSET
    r"""Batch information for this unit."""

    children: Optional[List[UnitGetChild]] = None
    r"""Child units with part details."""

    created_during: OptionalNullable[CreatedDuring] = UNSET
    r"""Run that created this unit."""

    attachments: Optional[List[UnitGetAttachment]] = None
    r"""Files attached to this unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "created_by_user",
            "created_by_station",
            "batch",
            "children",
            "created_during",
            "attachments",
        ]
        nullable_fields = [
            "created_by_user",
            "created_by_station",
            "batch",
            "parent",
            "created_during",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
