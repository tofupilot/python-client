"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from pydantic import model_serializer
from tofupilot.v2.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from tofupilot.v2.utils import FieldMetadata, PathParamMetadata
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class UnitGetRequestTypedDict(TypedDict):
    serial_number: str
    r"""Serial number of the unit to retrieve."""


class UnitGetRequest(BaseModel):
    serial_number: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""Serial number of the unit to retrieve."""


class UnitGetInternalServerErrorIssueTypedDict(TypedDict):
    message: str


class UnitGetInternalServerErrorIssue(BaseModel):
    message: str


class UnitGetNotFoundIssueTypedDict(TypedDict):
    message: str


class UnitGetNotFoundIssue(BaseModel):
    message: str


class UnitGetCreatedByUserTypedDict(TypedDict):
    r"""User who created this unit."""

    id: str
    r"""User ID."""
    name: Nullable[str]
    r"""User display name."""
    image: Nullable[str]
    r"""User profile image URL."""


class UnitGetCreatedByUser(BaseModel):
    r"""User who created this unit."""

    id: str
    r"""User ID."""

    name: Nullable[str]
    r"""User display name."""

    image: Nullable[str]
    r"""User profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetCreatedByStationTypedDict(TypedDict):
    r"""Station that created this unit."""

    id: str
    r"""Station ID."""
    name: Nullable[str]
    r"""Station name."""
    image: Nullable[str]
    r"""Station image URL."""


class UnitGetCreatedByStation(BaseModel):
    r"""Station that created this unit."""

    id: str
    r"""Station ID."""

    name: Nullable[str]
    r"""Station name."""

    image: Nullable[str]
    r"""Station image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetRevisionTypedDict(TypedDict):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class UnitGetRevision(BaseModel):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetPartTypedDict(TypedDict):
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: UnitGetRevisionTypedDict
    r"""Revision information for this unit."""


class UnitGetPart(BaseModel):
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: UnitGetRevision
    r"""Revision information for this unit."""


class UnitGetBatchTypedDict(TypedDict):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""
    number: str
    r"""Batch number."""


class UnitGetBatch(BaseModel):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""

    number: str
    r"""Batch number."""


class ParentRevisionTypedDict(TypedDict):
    r"""Part revision information with processed image URL."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class ParentRevision(BaseModel):
    r"""Part revision information with processed image URL."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ParentPartTypedDict(TypedDict):
    r"""Part information for the parent unit."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: Nullable[ParentRevisionTypedDict]
    r"""Part revision information with processed image URL."""


class ParentPart(BaseModel):
    r"""Part information for the parent unit."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: Nullable[ParentRevision]
    r"""Part revision information with processed image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["revision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetParentTypedDict(TypedDict):
    r"""Parent unit information with part details and processed images."""

    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: Nullable[ParentPartTypedDict]
    r"""Part information for the parent unit."""


class UnitGetParent(BaseModel):
    r"""Parent unit information with part details and processed images."""

    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: Nullable[ParentPart]
    r"""Part information for the parent unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["part"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ChildRevisionTypedDict(TypedDict):
    r"""Part revision information with processed image URL."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class ChildRevision(BaseModel):
    r"""Part revision information with processed image URL."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ChildPartTypedDict(TypedDict):
    r"""Part information for the child unit."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: Nullable[ChildRevisionTypedDict]
    r"""Part revision information with processed image URL."""


class ChildPart(BaseModel):
    r"""Part information for the child unit."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: Nullable[ChildRevision]
    r"""Part revision information with processed image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["revision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetChildTypedDict(TypedDict):
    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: Nullable[ChildPartTypedDict]
    r"""Part information for the child unit."""


class UnitGetChild(BaseModel):
    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: Nullable[ChildPart]
    r"""Part information for the child unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["part"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


CreatedFromOutcome = Literal["PASS", "FAIL", "ERROR", "TIMEOUT", "ABORTED"]
r"""Final result of the run execution."""


class CreatedFromProcedureTypedDict(TypedDict):
    r"""Procedure information."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""


class CreatedFromProcedure(BaseModel):
    r"""Procedure information."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""


class CreatedFromTypedDict(TypedDict):
    r"""Run that created this unit."""

    id: str
    r"""Run ID."""
    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""
    started_at: datetime
    r"""ISO 8601 timestamp when the run started."""
    outcome: CreatedFromOutcome
    r"""Final result of the run execution."""
    duration: str
    r"""ISO 8601 duration string."""
    procedure: CreatedFromProcedureTypedDict
    r"""Procedure information."""


class CreatedFrom(BaseModel):
    r"""Run that created this unit."""

    id: str
    r"""Run ID."""

    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""

    started_at: datetime
    r"""ISO 8601 timestamp when the run started."""

    outcome: CreatedFromOutcome
    r"""Final result of the run execution."""

    duration: str
    r"""ISO 8601 duration string."""

    procedure: CreatedFromProcedure
    r"""Procedure information."""


class ParentChangeCreatedByUserTypedDict(TypedDict):
    r"""User who made the parent change."""

    id: str
    r"""User ID."""
    name: str
    r"""User display name."""


class ParentChangeCreatedByUser(BaseModel):
    r"""User who made the parent change."""

    id: str
    r"""User ID."""

    name: str
    r"""User display name."""


class ParentChangeCreatedByStationTypedDict(TypedDict):
    r"""Station that made the parent change."""

    id: str
    r"""Station ID."""
    name: str
    r"""Station name."""


class ParentChangeCreatedByStation(BaseModel):
    r"""Station that made the parent change."""

    id: str
    r"""Station ID."""

    name: str
    r"""Station name."""


class ParentChangeProcedureTypedDict(TypedDict):
    r"""Procedure associated with the run."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""


class ParentChangeProcedure(BaseModel):
    r"""Procedure associated with the run."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""


class ParentChangeRunTypedDict(TypedDict):
    r"""Run that triggered the parent change."""

    id: str
    r"""Run ID."""
    procedure: Nullable[ParentChangeProcedureTypedDict]
    r"""Procedure associated with the run."""


class ParentChangeRun(BaseModel):
    r"""Run that triggered the parent change."""

    id: str
    r"""Run ID."""

    procedure: Nullable[ParentChangeProcedure]
    r"""Procedure associated with the run."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["procedure"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ParentChangeRevisionTypedDict(TypedDict):
    r"""Revision information."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class ParentChangeRevision(BaseModel):
    r"""Revision information."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class ParentChangePartTypedDict(TypedDict):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: Nullable[ParentChangeRevisionTypedDict]
    r"""Revision information."""


class ParentChangePart(BaseModel):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: Nullable[ParentChangeRevision]
    r"""Revision information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["revision"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetUnitTypedDict(TypedDict):
    r"""Unit involved in the parent change."""

    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: Nullable[ParentChangePartTypedDict]
    r"""Part information with revision details."""


class UnitGetUnit(BaseModel):
    r"""Unit involved in the parent change."""

    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: Nullable[ParentChangePart]
    r"""Part information with revision details."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["part"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class OldTypedDict(TypedDict):
    r"""Previous parent unit (null if this was the first parent assignment)."""

    id: str
    r"""Previous parent unit ID."""
    serial_number: str
    r"""Previous parent unit serial number."""


class Old(BaseModel):
    r"""Previous parent unit (null if this was the first parent assignment)."""

    id: str
    r"""Previous parent unit ID."""

    serial_number: str
    r"""Previous parent unit serial number."""


class NewTypedDict(TypedDict):
    r"""New parent unit (null if parent was removed)."""

    id: str
    r"""New parent unit ID."""
    serial_number: str
    r"""New parent unit serial number."""


class New(BaseModel):
    r"""New parent unit (null if parent was removed)."""

    id: str
    r"""New parent unit ID."""

    serial_number: str
    r"""New parent unit serial number."""


class ParentChangeTypedDict(TypedDict):
    id: str
    r"""Parent change ID."""
    created_at: datetime
    r"""ISO 8601 timestamp when the parent change occurred."""
    created_by_user: Nullable[ParentChangeCreatedByUserTypedDict]
    r"""User who made the parent change."""
    created_by_station: Nullable[ParentChangeCreatedByStationTypedDict]
    r"""Station that made the parent change."""
    run: Nullable[ParentChangeRunTypedDict]
    r"""Run that triggered the parent change."""
    unit: Nullable[UnitGetUnitTypedDict]
    r"""Unit involved in the parent change."""
    old: Nullable[OldTypedDict]
    r"""Previous parent unit (null if this was the first parent assignment)."""
    new: Nullable[NewTypedDict]
    r"""New parent unit (null if parent was removed)."""


class ParentChange(BaseModel):
    id: str
    r"""Parent change ID."""

    created_at: datetime
    r"""ISO 8601 timestamp when the parent change occurred."""

    created_by_user: Nullable[ParentChangeCreatedByUser]
    r"""User who made the parent change."""

    created_by_station: Nullable[ParentChangeCreatedByStation]
    r"""Station that made the parent change."""

    run: Nullable[ParentChangeRun]
    r"""Run that triggered the parent change."""

    unit: Nullable[UnitGetUnit]
    r"""Unit involved in the parent change."""

    old: Nullable[Old]
    r"""Previous parent unit (null if this was the first parent assignment)."""

    new: Nullable[New]
    r"""New parent unit (null if parent was removed)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "created_by_user",
            "created_by_station",
            "run",
            "unit",
            "old",
            "new",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


UnitGetRunOutcome = Literal["PASS", "FAIL", "ERROR", "TIMEOUT", "ABORTED"]
r"""Final result of the run execution."""


class UnitGetRunProcedureTypedDict(TypedDict):
    r"""Test procedure associated with this run. Every run must have a procedure."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""


class UnitGetRunProcedure(BaseModel):
    r"""Test procedure associated with this run. Every run must have a procedure."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""


class RunCreatedByUserTypedDict(TypedDict):
    r"""User who created this run."""

    id: str
    r"""User ID."""
    name: Nullable[str]
    r"""User display name."""
    image: Nullable[str]
    r"""User profile image URL."""


class RunCreatedByUser(BaseModel):
    r"""User who created this run."""

    id: str
    r"""User ID."""

    name: Nullable[str]
    r"""User display name."""

    image: Nullable[str]
    r"""User profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunCreatedByStationTypedDict(TypedDict):
    r"""Station that created this run."""

    id: str
    r"""Station ID."""
    name: Nullable[str]
    r"""Station name."""
    image: Nullable[str]
    r"""Station image URL."""


class RunCreatedByStation(BaseModel):
    r"""Station that created this run."""

    id: str
    r"""Station ID."""

    name: Nullable[str]
    r"""Station name."""

    image: Nullable[str]
    r"""Station image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetRunTypedDict(TypedDict):
    id: str
    r"""Run ID."""
    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""
    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""
    outcome: UnitGetRunOutcome
    r"""Final result of the run execution."""
    duration: str
    r"""ISO 8601 duration string representing the total execution time."""
    procedure: UnitGetRunProcedureTypedDict
    r"""Test procedure associated with this run. Every run must have a procedure."""
    created_by_user: NotRequired[Nullable[RunCreatedByUserTypedDict]]
    r"""User who created this run."""
    created_by_station: NotRequired[Nullable[RunCreatedByStationTypedDict]]
    r"""Station that created this run."""


class UnitGetRun(BaseModel):
    id: str
    r"""Run ID."""

    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""

    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""

    outcome: UnitGetRunOutcome
    r"""Final result of the run execution."""

    duration: str
    r"""ISO 8601 duration string representing the total execution time."""

    procedure: UnitGetRunProcedure
    r"""Test procedure associated with this run. Every run must have a procedure."""

    created_by_user: OptionalNullable[RunCreatedByUser] = UNSET
    r"""User who created this run."""

    created_by_station: OptionalNullable[RunCreatedByStation] = UNSET
    r"""Station that created this run."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["created_by_user", "created_by_station"]
        nullable_fields = ["created_by_user", "created_by_station"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class UnitGetResponseTypedDict(TypedDict):
    r"""Units retrieved successfully"""

    id: str
    r"""Unique identifier for the unit."""
    serial_number: str
    r"""Unit serial number."""
    created_at: datetime
    r"""ISO 8601 timestamp when the unit was created."""
    part: UnitGetPartTypedDict
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""
    parent: Nullable[UnitGetParentTypedDict]
    r"""Parent unit information with part details and processed images."""
    created_by_user: NotRequired[Nullable[UnitGetCreatedByUserTypedDict]]
    r"""User who created this unit."""
    created_by_station: NotRequired[Nullable[UnitGetCreatedByStationTypedDict]]
    r"""Station that created this unit."""
    batch: NotRequired[Nullable[UnitGetBatchTypedDict]]
    r"""Batch information for this unit."""
    children: NotRequired[List[UnitGetChildTypedDict]]
    r"""Child units with part details and processed images."""
    created_from: NotRequired[Nullable[CreatedFromTypedDict]]
    r"""Run that created this unit."""
    parent_changes: NotRequired[List[ParentChangeTypedDict]]
    r"""Parent change history showing when the unit's parent relationships were modified."""
    runs: NotRequired[List[UnitGetRunTypedDict]]
    r"""All test runs performed on this unit."""


class UnitGetResponse(BaseModel):
    r"""Units retrieved successfully"""

    id: str
    r"""Unique identifier for the unit."""

    serial_number: str
    r"""Unit serial number."""

    created_at: datetime
    r"""ISO 8601 timestamp when the unit was created."""

    part: UnitGetPart
    r"""Part information with revision details for this unit. Every unit must have a part and revision."""

    parent: Nullable[UnitGetParent]
    r"""Parent unit information with part details and processed images."""

    created_by_user: OptionalNullable[UnitGetCreatedByUser] = UNSET
    r"""User who created this unit."""

    created_by_station: OptionalNullable[UnitGetCreatedByStation] = UNSET
    r"""Station that created this unit."""

    batch: OptionalNullable[UnitGetBatch] = UNSET
    r"""Batch information for this unit."""

    children: Optional[List[UnitGetChild]] = None
    r"""Child units with part details and processed images."""

    created_from: OptionalNullable[CreatedFrom] = UNSET
    r"""Run that created this unit."""

    parent_changes: Optional[List[ParentChange]] = None
    r"""Parent change history showing when the unit's parent relationships were modified."""

    runs: Optional[List[UnitGetRun]] = None
    r"""All test runs performed on this unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "created_by_user",
            "created_by_station",
            "batch",
            "children",
            "created_from",
            "parent_changes",
            "runs",
        ]
        nullable_fields = [
            "created_by_user",
            "created_by_station",
            "batch",
            "parent",
            "created_from",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
