"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from pydantic import model_serializer
from tofupilot.v2.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from tofupilot.v2.utils import FieldMetadata, PathParamMetadata
from typing import List, Literal, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class RunGetRequestTypedDict(TypedDict):
    id: str
    r"""ID of the run to retrieve."""


class RunGetRequest(BaseModel):
    id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""ID of the run to retrieve."""


RunGetOutcome = Literal["PASS", "FAIL", "ERROR", "TIMEOUT", "ABORTED"]
r"""Final result of the run execution."""


class RunGetCreatedByUserTypedDict(TypedDict):
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""User ID."""
    name: Nullable[str]
    r"""User display name."""
    email: Nullable[str]
    r"""User email address."""
    image: Nullable[str]
    r"""User profile image URL."""


class RunGetCreatedByUser(BaseModel):
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""User ID."""

    name: Nullable[str]
    r"""User display name."""

    email: Nullable[str]
    r"""User email address."""

    image: Nullable[str]
    r"""User profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "email", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunGetCreatedByStationTypedDict(TypedDict):
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""Station ID."""
    name: Nullable[str]
    r"""Station name."""
    image: Nullable[str]
    r"""Station image URL."""


class RunGetCreatedByStation(BaseModel):
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""Station ID."""

    name: Nullable[str]
    r"""Station name."""

    image: Nullable[str]
    r"""Station image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunGetOperatedByTypedDict(TypedDict):
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    id: str
    r"""Operator ID."""
    name: Nullable[str]
    r"""Operator display name."""
    email: Nullable[str]
    r"""Operator email address."""
    image: Nullable[str]
    r"""Operator profile image URL."""


class RunGetOperatedBy(BaseModel):
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    id: str
    r"""Operator ID."""

    name: Nullable[str]
    r"""Operator display name."""

    email: Nullable[str]
    r"""Operator email address."""

    image: Nullable[str]
    r"""Operator profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["name", "email", "image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunGetVersionTypedDict(TypedDict):
    r"""Version of the procedure used for this run."""

    id: str
    r"""Procedure version ID."""
    tag: str
    r"""Version tag."""


class RunGetVersion(BaseModel):
    r"""Version of the procedure used for this run."""

    id: str
    r"""Procedure version ID."""

    tag: str
    r"""Version tag."""


class RunGetProcedureTypedDict(TypedDict):
    r"""Test procedure associated with this run."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""
    version: Nullable[RunGetVersionTypedDict]
    r"""Version of the procedure used for this run."""


class RunGetProcedure(BaseModel):
    r"""Test procedure associated with this run."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""

    version: Nullable[RunGetVersion]
    r"""Version of the procedure used for this run."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["version"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunGetRevisionTypedDict(TypedDict):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class RunGetRevision(BaseModel):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["image"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class RunGetPartTypedDict(TypedDict):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: RunGetRevisionTypedDict
    r"""Revision information for this unit."""


class RunGetPart(BaseModel):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: RunGetRevision
    r"""Revision information for this unit."""


class RunGetBatchTypedDict(TypedDict):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""
    number: str
    r"""Batch number."""


class RunGetBatch(BaseModel):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""

    number: str
    r"""Batch number."""


class RunGetUnitTypedDict(TypedDict):
    r"""Unit under test information."""

    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: RunGetPartTypedDict
    r"""Part information with revision details."""
    batch: NotRequired[Nullable[RunGetBatchTypedDict]]
    r"""Batch information for this unit."""


class RunGetUnit(BaseModel):
    r"""Unit under test information."""

    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: RunGetPart
    r"""Part information with revision details."""

    batch: OptionalNullable[RunGetBatch] = UNSET
    r"""Batch information for this unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["batch"]
        nullable_fields = ["batch"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


RunGetPhaseOutcome = Literal["PASS", "FAIL", "SKIP", "ERROR"]
r"""Phase execution result."""


class RunGetMeasurementTypedDict(TypedDict):
    r"""Measurement result with validation status and limits."""


class RunGetMeasurement(BaseModel):
    r"""Measurement result with validation status and limits."""


class RunGetPhaseTypedDict(TypedDict):
    id: str
    r"""Phase ID."""
    name: str
    r"""Phase name."""
    outcome: RunGetPhaseOutcome
    r"""Phase execution result."""
    started_at: datetime
    r"""ISO 8601 timestamp when the phase started."""
    ended_at: datetime
    r"""ISO 8601 timestamp when the phase ended."""
    duration: str
    r"""ISO 8601 duration string for phase execution time."""
    docstring: NotRequired[Nullable[str]]
    r"""Phase documentation string."""
    measurements: NotRequired[List[RunGetMeasurementTypedDict]]
    r"""Array of measurements taken during this phase. Only returned if `all` or `measurements` is included, requires `phases` to be included)"""


class RunGetPhase(BaseModel):
    id: str
    r"""Phase ID."""

    name: str
    r"""Phase name."""

    outcome: RunGetPhaseOutcome
    r"""Phase execution result."""

    started_at: datetime
    r"""ISO 8601 timestamp when the phase started."""

    ended_at: datetime
    r"""ISO 8601 timestamp when the phase ended."""

    duration: str
    r"""ISO 8601 duration string for phase execution time."""

    docstring: OptionalNullable[str] = UNSET
    r"""Phase documentation string."""

    measurements: Optional[List[RunGetMeasurement]] = None
    r"""Array of measurements taken during this phase. Only returned if `all` or `measurements` is included, requires `phases` to be included)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["docstring", "measurements"]
        nullable_fields = ["docstring"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class AttachmentTypedDict(TypedDict):
    id: str
    r"""Attachment ID."""
    name: str
    r"""File name."""
    size: Nullable[float]
    r"""File size in bytes."""
    content_type: Nullable[str]
    r"""MIME type of the file."""
    is_report: bool
    r"""Whether this attachment is a test report (from file import) or a regular attachment."""
    download_url: NotRequired[Nullable[str]]
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""


class Attachment(BaseModel):
    id: str
    r"""Attachment ID."""

    name: str
    r"""File name."""

    size: Nullable[float]
    r"""File size in bytes."""

    content_type: Nullable[str]
    r"""MIME type of the file."""

    is_report: bool
    r"""Whether this attachment is a test report (from file import) or a regular attachment."""

    download_url: OptionalNullable[str] = UNSET
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["download_url"]
        nullable_fields = ["size", "content_type", "download_url"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


RunGetLevel = Literal["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"]


class RunGetLogTypedDict(TypedDict):
    id: str
    level: RunGetLevel
    timestamp: datetime
    message: str
    source_file: str
    line_number: float


class RunGetLog(BaseModel):
    id: str

    level: RunGetLevel

    timestamp: datetime

    message: str

    source_file: str

    line_number: float


class SubUnitTypedDict(TypedDict):
    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""


class SubUnit(BaseModel):
    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""


class RunGetResponseTypedDict(TypedDict):
    r"""Single test run details."""

    id: str
    r"""Unique identifier for the run."""
    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""
    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""
    ended_at: datetime
    r"""ISO 8601 timestamp when the run execution ended."""
    duration: str
    r"""ISO 8601 duration string representing the total execution time."""
    outcome: RunGetOutcome
    r"""Final result of the run execution."""
    procedure: RunGetProcedureTypedDict
    r"""Test procedure associated with this run."""
    unit: RunGetUnitTypedDict
    r"""Unit under test information."""
    docstring: NotRequired[Nullable[str]]
    r"""Additional notes or documentation about this test run."""
    created_by_user: NotRequired[Nullable[RunGetCreatedByUserTypedDict]]
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""
    created_by_station: NotRequired[Nullable[RunGetCreatedByStationTypedDict]]
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""
    operated_by: NotRequired[Nullable[RunGetOperatedByTypedDict]]
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""
    phases: NotRequired[List[RunGetPhaseTypedDict]]
    r"""Array of execution phases in this run. Only returned if `all` or `phases` is included."""
    attachments: NotRequired[List[AttachmentTypedDict]]
    r"""Files attached to this run, including both regular attachments and test reports. Only returned if `all` or `attachments` is included."""
    logs: NotRequired[List[RunGetLogTypedDict]]
    sub_units: NotRequired[List[SubUnitTypedDict]]
    r"""Array of sub-units that had parent changes during this run. Only returned if `all` or `sub_units` is included."""


class RunGetResponse(BaseModel):
    r"""Single test run details."""

    id: str
    r"""Unique identifier for the run."""

    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""

    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""

    ended_at: datetime
    r"""ISO 8601 timestamp when the run execution ended."""

    duration: str
    r"""ISO 8601 duration string representing the total execution time."""

    outcome: RunGetOutcome
    r"""Final result of the run execution."""

    procedure: RunGetProcedure
    r"""Test procedure associated with this run."""

    unit: RunGetUnit
    r"""Unit under test information."""

    docstring: OptionalNullable[str] = UNSET
    r"""Additional notes or documentation about this test run."""

    created_by_user: OptionalNullable[RunGetCreatedByUser] = UNSET
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    created_by_station: OptionalNullable[RunGetCreatedByStation] = UNSET
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    operated_by: OptionalNullable[RunGetOperatedBy] = UNSET
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    phases: Optional[List[RunGetPhase]] = None
    r"""Array of execution phases in this run. Only returned if `all` or `phases` is included."""

    attachments: Optional[List[Attachment]] = None
    r"""Files attached to this run, including both regular attachments and test reports. Only returned if `all` or `attachments` is included."""

    logs: Optional[List[RunGetLog]] = None

    sub_units: Optional[List[SubUnit]] = None
    r"""Array of sub-units that had parent changes during this run. Only returned if `all` or `sub_units` is included."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "docstring",
            "created_by_user",
            "created_by_station",
            "operated_by",
            "phases",
            "attachments",
            "logs",
            "sub_units",
        ]
        nullable_fields = [
            "docstring",
            "created_by_user",
            "created_by_station",
            "operated_by",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
