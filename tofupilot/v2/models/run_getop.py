"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from pydantic import model_serializer
from tofupilot.v2.types import (
    BaseModel,
    Nullable,
    OptionalNullable,
    UNSET,
    UNSET_SENTINEL,
)
from tofupilot.v2.utils import FieldMetadata, PathParamMetadata
from typing import Any, Dict, List, Literal, Optional, Union
from typing_extensions import Annotated, NotRequired, TypeAliasType, TypedDict


class RunGetRequestTypedDict(TypedDict):
    id: str
    r"""ID of the run to retrieve."""


class RunGetRequest(BaseModel):
    id: Annotated[
        str, FieldMetadata(path=PathParamMetadata(style="simple", explode=False))
    ]
    r"""ID of the run to retrieve."""


RunGetOutcome = Literal[
    "PASS",
    "FAIL",
    "ERROR",
    "TIMEOUT",
    "ABORTED",
]
r"""Final result of the run execution."""


class RunGetCreatedByUserTypedDict(TypedDict):
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""User ID."""
    name: Nullable[str]
    r"""User display name."""
    email: Nullable[str]
    r"""User email address."""
    image: Nullable[str]
    r"""User profile image URL."""


class RunGetCreatedByUser(BaseModel):
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""User ID."""

    name: Nullable[str]
    r"""User display name."""

    email: Nullable[str]
    r"""User email address."""

    image: Nullable[str]
    r"""User profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetCreatedByStationTypedDict(TypedDict):
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""Station ID."""
    name: Nullable[str]
    r"""Station name."""
    image: Nullable[str]
    r"""Station image URL."""


class RunGetCreatedByStation(BaseModel):
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    id: str
    r"""Station ID."""

    name: Nullable[str]
    r"""Station name."""

    image: Nullable[str]
    r"""Station image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetOperatedByTypedDict(TypedDict):
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    id: str
    r"""Operator ID."""
    name: Nullable[str]
    r"""Operator display name."""
    email: Nullable[str]
    r"""Operator email address."""
    image: Nullable[str]
    r"""Operator profile image URL."""


class RunGetOperatedBy(BaseModel):
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    id: str
    r"""Operator ID."""

    name: Nullable[str]
    r"""Operator display name."""

    email: Nullable[str]
    r"""Operator email address."""

    image: Nullable[str]
    r"""Operator profile image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetVersionTypedDict(TypedDict):
    r"""Version of the procedure used for this run."""

    id: str
    r"""Procedure version ID."""
    tag: str
    r"""Version tag."""


class RunGetVersion(BaseModel):
    r"""Version of the procedure used for this run."""

    id: str
    r"""Procedure version ID."""

    tag: str
    r"""Version tag."""


class RunGetProcedureTypedDict(TypedDict):
    r"""Test procedure associated with this run."""

    id: str
    r"""Procedure ID."""
    name: str
    r"""Procedure name."""
    version: Nullable[RunGetVersionTypedDict]
    r"""Version of the procedure used for this run."""


class RunGetProcedure(BaseModel):
    r"""Test procedure associated with this run."""

    id: str
    r"""Procedure ID."""

    name: str
    r"""Procedure name."""

    version: Nullable[RunGetVersion]
    r"""Version of the procedure used for this run."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetRevisionTypedDict(TypedDict):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""
    number: str
    r"""Revision number."""
    image: Nullable[str]
    r"""Revision image URL."""


class RunGetRevision(BaseModel):
    r"""Revision information for this unit."""

    id: str
    r"""Revision ID."""

    number: str
    r"""Revision number."""

    image: Nullable[str]
    r"""Revision image URL."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetPartTypedDict(TypedDict):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""
    number: str
    r"""Part number."""
    name: str
    r"""Part name."""
    revision: RunGetRevisionTypedDict
    r"""Revision information for this unit."""


class RunGetPart(BaseModel):
    r"""Part information with revision details."""

    id: str
    r"""Part ID."""

    number: str
    r"""Part number."""

    name: str
    r"""Part name."""

    revision: RunGetRevision
    r"""Revision information for this unit."""


class RunGetBatchTypedDict(TypedDict):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""
    number: str
    r"""Batch number."""


class RunGetBatch(BaseModel):
    r"""Batch information for this unit."""

    id: str
    r"""Batch ID."""

    number: str
    r"""Batch number."""


class RunGetUnitTypedDict(TypedDict):
    r"""Unit under test information."""

    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""
    part: RunGetPartTypedDict
    r"""Part information with revision details."""
    batch: NotRequired[Nullable[RunGetBatchTypedDict]]
    r"""Batch information for this unit."""


class RunGetUnit(BaseModel):
    r"""Unit under test information."""

    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""

    part: RunGetPart
    r"""Part information with revision details."""

    batch: OptionalNullable[RunGetBatch] = UNSET
    r"""Batch information for this unit."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["batch"])
        nullable_fields = set(["batch"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RunGetPhaseOutcome = Literal[
    "PASS",
    "FAIL",
    "SKIP",
    "ERROR",
]
r"""Phase execution result."""


RunGetMeasurementOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Measurement validation result."""


RunGetValidatorOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Validation result: PASS, FAIL, or UNSET."""


RunGetExpectedValueTypedDict = TypeAliasType(
    "RunGetExpectedValueTypedDict", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


RunGetExpectedValue = TypeAliasType(
    "RunGetExpectedValue", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


class RunGetValidatorTypedDict(TypedDict):
    r"""Validator result with outcome and comparison details."""

    outcome: RunGetValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""
    operator: Nullable[str]
    r"""Comparison operator used for validation."""
    expected_value: Nullable[RunGetExpectedValueTypedDict]
    r"""Expected value for comparison. Type depends on measurement type."""
    expression: str
    r"""Human-readable expression string for display."""
    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""
    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""
    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""
    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""


class RunGetValidator(BaseModel):
    r"""Validator result with outcome and comparison details."""

    outcome: RunGetValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""

    operator: Nullable[str]
    r"""Comparison operator used for validation."""

    expected_value: Nullable[RunGetExpectedValue]
    r"""Expected value for comparison. Type depends on measurement type."""

    expression: str
    r"""Human-readable expression string for display."""

    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""

    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""

    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""

    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


RunGetAggregationOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""


RunGetValueTypedDict = TypeAliasType("RunGetValueTypedDict", Union[float, str, bool])
r"""Computed aggregation value. Type depends on aggregation type."""


RunGetValue = TypeAliasType("RunGetValue", Union[float, str, bool])
r"""Computed aggregation value. Type depends on aggregation type."""


RunGetAggregationValidatorOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Validation result: PASS, FAIL, or UNSET."""


RunGetAggregationExpectedValueTypedDict = TypeAliasType(
    "RunGetAggregationExpectedValueTypedDict",
    Union[bool, float, str, List[float], List[str]],
)
r"""Expected value for comparison. Type depends on measurement type."""


RunGetAggregationExpectedValue = TypeAliasType(
    "RunGetAggregationExpectedValue", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


class RunGetAggregationValidatorTypedDict(TypedDict):
    r"""Validator result with outcome and comparison details."""

    outcome: RunGetAggregationValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""
    operator: Nullable[str]
    r"""Comparison operator used for validation."""
    expected_value: Nullable[RunGetAggregationExpectedValueTypedDict]
    r"""Expected value for comparison. Type depends on measurement type."""
    expression: str
    r"""Human-readable expression string for display."""
    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""
    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""
    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""
    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""


class RunGetAggregationValidator(BaseModel):
    r"""Validator result with outcome and comparison details."""

    outcome: RunGetAggregationValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""

    operator: Nullable[str]
    r"""Comparison operator used for validation."""

    expected_value: Nullable[RunGetAggregationExpectedValue]
    r"""Expected value for comparison. Type depends on measurement type."""

    expression: str
    r"""Human-readable expression string for display."""

    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""

    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""

    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""

    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class RunGetAggregationTypedDict(TypedDict):
    r"""Aggregation result with computed value and optional validators."""

    id: str
    r"""Unique identifier for the aggregation."""
    type: str
    r"""Aggregation type (e.g., MIN, MAX, MEAN, RANGE, STD_DEV)."""
    outcome: Nullable[RunGetAggregationOutcome]
    r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""
    value: Nullable[RunGetValueTypedDict]
    r"""Computed aggregation value. Type depends on aggregation type."""
    unit: NotRequired[Nullable[str]]
    r"""Unit of measurement for the aggregated value."""
    validators: NotRequired[Nullable[List[RunGetAggregationValidatorTypedDict]]]
    r"""Validators applied to the aggregated value."""


class RunGetAggregation(BaseModel):
    r"""Aggregation result with computed value and optional validators."""

    id: str
    r"""Unique identifier for the aggregation."""

    type: str
    r"""Aggregation type (e.g., MIN, MAX, MEAN, RANGE, STD_DEV)."""

    outcome: Nullable[RunGetAggregationOutcome]
    r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""

    value: Nullable[RunGetValue]
    r"""Computed aggregation value. Type depends on aggregation type."""

    unit: OptionalNullable[str] = UNSET
    r"""Unit of measurement for the aggregated value."""

    validators: OptionalNullable[List[RunGetAggregationValidator]] = UNSET
    r"""Validators applied to the aggregated value."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["unit", "validators"])
        nullable_fields = set(["outcome", "value", "unit", "validators"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RunGetMeasuredValueTypedDict = TypeAliasType(
    "RunGetMeasuredValueTypedDict",
    Union[float, str, bool, List[List[float]], Dict[str, Any], List[Any]],
)
r"""The actual measured value."""


RunGetMeasuredValue = TypeAliasType(
    "RunGetMeasuredValue",
    Union[float, str, bool, List[List[float]], Dict[str, Any], List[Any]],
)
r"""The actual measured value."""


DataSeryValidatorOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Validation result: PASS, FAIL, or UNSET."""


DataSeryExpectedValueTypedDict = TypeAliasType(
    "DataSeryExpectedValueTypedDict", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


DataSeryExpectedValue = TypeAliasType(
    "DataSeryExpectedValue", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


class DataSeryValidatorTypedDict(TypedDict):
    r"""Validator result with outcome and comparison details."""

    outcome: DataSeryValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""
    operator: Nullable[str]
    r"""Comparison operator used for validation."""
    expected_value: Nullable[DataSeryExpectedValueTypedDict]
    r"""Expected value for comparison. Type depends on measurement type."""
    expression: str
    r"""Human-readable expression string for display."""
    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""
    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""
    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""
    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""


class DataSeryValidator(BaseModel):
    r"""Validator result with outcome and comparison details."""

    outcome: DataSeryValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""

    operator: Nullable[str]
    r"""Comparison operator used for validation."""

    expected_value: Nullable[DataSeryExpectedValue]
    r"""Expected value for comparison. Type depends on measurement type."""

    expression: str
    r"""Human-readable expression string for display."""

    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""

    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""

    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""

    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


DataSeryAggregationOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""


DataSeryValueTypedDict = TypeAliasType(
    "DataSeryValueTypedDict", Union[float, str, bool]
)
r"""Computed aggregation value. Type depends on aggregation type."""


DataSeryValue = TypeAliasType("DataSeryValue", Union[float, str, bool])
r"""Computed aggregation value. Type depends on aggregation type."""


DataSeryAggregationValidatorOutcome = Literal[
    "PASS",
    "FAIL",
    "UNSET",
]
r"""Validation result: PASS, FAIL, or UNSET."""


DataSeryAggregationExpectedValueTypedDict = TypeAliasType(
    "DataSeryAggregationExpectedValueTypedDict",
    Union[bool, float, str, List[float], List[str]],
)
r"""Expected value for comparison. Type depends on measurement type."""


DataSeryAggregationExpectedValue = TypeAliasType(
    "DataSeryAggregationExpectedValue", Union[bool, float, str, List[float], List[str]]
)
r"""Expected value for comparison. Type depends on measurement type."""


class DataSeryAggregationValidatorTypedDict(TypedDict):
    r"""Validator result with outcome and comparison details."""

    outcome: DataSeryAggregationValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""
    operator: Nullable[str]
    r"""Comparison operator used for validation."""
    expected_value: Nullable[DataSeryAggregationExpectedValueTypedDict]
    r"""Expected value for comparison. Type depends on measurement type."""
    expression: str
    r"""Human-readable expression string for display."""
    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""
    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""
    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""
    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""


class DataSeryAggregationValidator(BaseModel):
    r"""Validator result with outcome and comparison details."""

    outcome: DataSeryAggregationValidatorOutcome
    r"""Validation result: PASS, FAIL, or UNSET."""

    operator: Nullable[str]
    r"""Comparison operator used for validation."""

    expected_value: Nullable[DataSeryAggregationExpectedValue]
    r"""Expected value for comparison. Type depends on measurement type."""

    expression: str
    r"""Human-readable expression string for display."""

    is_decisive: Nullable[bool]
    r"""Whether this validator is decisive (if it fails, measurement fails). False for marginal/warning validators."""

    is_expression_only: bool
    r"""True if validator only has expression (no structured operator/expected_value)."""

    analytics_expression: Nullable[str]
    r"""Synthetic expression from operator+expected_value for analytics tooltip. Null if expression-only."""

    has_custom_expression: bool
    r"""True if user provided a custom expression (shown in italic with analytics tooltip)."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)

            if val != UNSET_SENTINEL:
                m[k] = val

        return m


class DataSeryAggregationTypedDict(TypedDict):
    r"""Aggregation result with computed value and optional validators."""

    id: str
    r"""Unique identifier for the aggregation."""
    type: str
    r"""Aggregation type (e.g., MIN, MAX, MEAN, RANGE, STD_DEV)."""
    outcome: Nullable[DataSeryAggregationOutcome]
    r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""
    value: Nullable[DataSeryValueTypedDict]
    r"""Computed aggregation value. Type depends on aggregation type."""
    unit: NotRequired[Nullable[str]]
    r"""Unit of measurement for the aggregated value."""
    validators: NotRequired[Nullable[List[DataSeryAggregationValidatorTypedDict]]]
    r"""Validators applied to the aggregated value."""


class DataSeryAggregation(BaseModel):
    r"""Aggregation result with computed value and optional validators."""

    id: str
    r"""Unique identifier for the aggregation."""

    type: str
    r"""Aggregation type (e.g., MIN, MAX, MEAN, RANGE, STD_DEV)."""

    outcome: Nullable[DataSeryAggregationOutcome]
    r"""Aggregation validation result: PASS, FAIL, UNSET, or null if no validators."""

    value: Nullable[DataSeryValue]
    r"""Computed aggregation value. Type depends on aggregation type."""

    unit: OptionalNullable[str] = UNSET
    r"""Unit of measurement for the aggregated value."""

    validators: OptionalNullable[List[DataSeryAggregationValidator]] = UNSET
    r"""Validators applied to the aggregated value."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["unit", "validators"])
        nullable_fields = set(["outcome", "value", "unit", "validators"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class DataSeryTypedDict(TypedDict):
    data: List[float]
    units: Nullable[str]
    validators: NotRequired[Nullable[List[DataSeryValidatorTypedDict]]]
    aggregations: NotRequired[Nullable[List[DataSeryAggregationTypedDict]]]


class DataSery(BaseModel):
    data: List[float]

    units: Nullable[str]

    validators: OptionalNullable[List[DataSeryValidator]] = UNSET

    aggregations: OptionalNullable[List[DataSeryAggregation]] = UNSET

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["validators", "aggregations"])
        nullable_fields = set(["units", "validators", "aggregations"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class RunGetMeasurementTypedDict(TypedDict):
    id: str
    r"""Measurement ID."""
    name: str
    r"""Measurement name."""
    outcome: RunGetMeasurementOutcome
    r"""Measurement validation result."""
    units: Nullable[str]
    r"""Units of measurement."""
    validators: Nullable[List[RunGetValidatorTypedDict]]
    r"""Structured validation rules with outcome and expected values."""
    aggregations: NotRequired[Nullable[List[RunGetAggregationTypedDict]]]
    r"""Aggregations computed over this measurement."""
    measured_value: NotRequired[RunGetMeasuredValueTypedDict]
    r"""The actual measured value."""
    data_series: NotRequired[List[DataSeryTypedDict]]
    r"""Multi-dimensional measurement data series."""


class RunGetMeasurement(BaseModel):
    id: str
    r"""Measurement ID."""

    name: str
    r"""Measurement name."""

    outcome: RunGetMeasurementOutcome
    r"""Measurement validation result."""

    units: Nullable[str]
    r"""Units of measurement."""

    validators: Nullable[List[RunGetValidator]]
    r"""Structured validation rules with outcome and expected values."""

    aggregations: OptionalNullable[List[RunGetAggregation]] = UNSET
    r"""Aggregations computed over this measurement."""

    measured_value: Optional[RunGetMeasuredValue] = None
    r"""The actual measured value."""

    data_series: Optional[List[DataSery]] = None
    r"""Multi-dimensional measurement data series."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["aggregations", "measured_value", "data_series"])
        nullable_fields = set(["units", "validators", "aggregations"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class RunGetPhaseTypedDict(TypedDict):
    id: str
    r"""Phase ID."""
    name: str
    r"""Phase name."""
    outcome: RunGetPhaseOutcome
    r"""Phase execution result."""
    started_at: datetime
    r"""ISO 8601 timestamp when the phase started."""
    ended_at: datetime
    r"""ISO 8601 timestamp when the phase ended."""
    duration: str
    r"""ISO 8601 duration of the phase (computed from started_at and ended_at)."""
    measurements: List[RunGetMeasurementTypedDict]
    r"""Array of measurements taken during this phase."""
    docstring: NotRequired[Nullable[str]]
    r"""Phase documentation string."""


class RunGetPhase(BaseModel):
    id: str
    r"""Phase ID."""

    name: str
    r"""Phase name."""

    outcome: RunGetPhaseOutcome
    r"""Phase execution result."""

    started_at: datetime
    r"""ISO 8601 timestamp when the phase started."""

    ended_at: datetime
    r"""ISO 8601 timestamp when the phase ended."""

    duration: str
    r"""ISO 8601 duration of the phase (computed from started_at and ended_at)."""

    measurements: List[RunGetMeasurement]
    r"""Array of measurements taken during this phase."""

    docstring: OptionalNullable[str] = UNSET
    r"""Phase documentation string."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["docstring"])
        nullable_fields = set(["docstring"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


class AttachmentTypedDict(TypedDict):
    id: str
    r"""Attachment ID."""
    name: str
    r"""File name."""
    size: Nullable[float]
    r"""File size in bytes."""
    content_type: Nullable[str]
    r"""MIME type of the file."""
    is_report: bool
    r"""Whether this attachment is a test report (from file import) or a regular attachment."""
    download_url: NotRequired[Nullable[str]]
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""


class Attachment(BaseModel):
    id: str
    r"""Attachment ID."""

    name: str
    r"""File name."""

    size: Nullable[float]
    r"""File size in bytes."""

    content_type: Nullable[str]
    r"""MIME type of the file."""

    is_report: bool
    r"""Whether this attachment is a test report (from file import) or a regular attachment."""

    download_url: OptionalNullable[str] = UNSET
    r"""Presigned URL for downloading the file. This URL is temporary and will expire."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(["download_url"])
        nullable_fields = set(["size", "content_type", "download_url"])
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m


RunGetLevel = Literal[
    "DEBUG",
    "INFO",
    "WARNING",
    "ERROR",
    "CRITICAL",
]


class RunGetLogTypedDict(TypedDict):
    id: str
    level: RunGetLevel
    timestamp: datetime
    message: str
    source_file: str
    line_number: float


class RunGetLog(BaseModel):
    id: str

    level: RunGetLevel

    timestamp: datetime

    message: str

    source_file: str

    line_number: float


class SubUnitTypedDict(TypedDict):
    id: str
    r"""Unit ID."""
    serial_number: str
    r"""Unit serial number."""


class SubUnit(BaseModel):
    id: str
    r"""Unit ID."""

    serial_number: str
    r"""Unit serial number."""


class RunGetResponseTypedDict(TypedDict):
    r"""Single test run details."""

    id: str
    r"""Unique identifier for the run."""
    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""
    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""
    ended_at: datetime
    r"""ISO 8601 timestamp when the run execution ended."""
    duration: str
    r"""ISO 8601 duration of the run (computed from started_at and ended_at)."""
    outcome: RunGetOutcome
    r"""Final result of the run execution."""
    procedure: RunGetProcedureTypedDict
    r"""Test procedure associated with this run."""
    unit: RunGetUnitTypedDict
    r"""Unit under test information."""
    docstring: NotRequired[Nullable[str]]
    r"""Additional notes or documentation about this test run."""
    created_by_user: NotRequired[Nullable[RunGetCreatedByUserTypedDict]]
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""
    created_by_station: NotRequired[Nullable[RunGetCreatedByStationTypedDict]]
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""
    operated_by: NotRequired[Nullable[RunGetOperatedByTypedDict]]
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""
    phases: NotRequired[List[RunGetPhaseTypedDict]]
    r"""Array of execution phases in this run. Only returned if `all` or `phases` is included."""
    attachments: NotRequired[List[AttachmentTypedDict]]
    r"""Files attached to this run, including both regular attachments and test reports. Only returned if `all` or `attachments` is included."""
    logs: NotRequired[List[RunGetLogTypedDict]]
    sub_units: NotRequired[List[SubUnitTypedDict]]
    r"""Array of sub-units that had parent changes during this run. Only returned if `all` or `sub_units` is included."""


class RunGetResponse(BaseModel):
    r"""Single test run details."""

    id: str
    r"""Unique identifier for the run."""

    created_at: datetime
    r"""ISO 8601 timestamp when the run was created."""

    started_at: datetime
    r"""ISO 8601 timestamp when the run execution started."""

    ended_at: datetime
    r"""ISO 8601 timestamp when the run execution ended."""

    duration: str
    r"""ISO 8601 duration of the run (computed from started_at and ended_at)."""

    outcome: RunGetOutcome
    r"""Final result of the run execution."""

    procedure: RunGetProcedure
    r"""Test procedure associated with this run."""

    unit: RunGetUnit
    r"""Unit under test information."""

    docstring: OptionalNullable[str] = UNSET
    r"""Additional notes or documentation about this test run."""

    created_by_user: OptionalNullable[RunGetCreatedByUser] = UNSET
    r"""User whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    created_by_station: OptionalNullable[RunGetCreatedByStation] = UNSET
    r"""Station whose API key was used to create this run. Only returned if `all` or `created_by` is included."""

    operated_by: OptionalNullable[RunGetOperatedBy] = UNSET
    r"""User who operated this run. Only returned if `all` or `operated_by` is included."""

    phases: Optional[List[RunGetPhase]] = None
    r"""Array of execution phases in this run. Only returned if `all` or `phases` is included."""

    attachments: Optional[List[Attachment]] = None
    r"""Files attached to this run, including both regular attachments and test reports. Only returned if `all` or `attachments` is included."""

    logs: Optional[List[RunGetLog]] = None

    sub_units: Optional[List[SubUnit]] = None
    r"""Array of sub-units that had parent changes during this run. Only returned if `all` or `sub_units` is included."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = set(
            [
                "docstring",
                "created_by_user",
                "created_by_station",
                "operated_by",
                "phases",
                "attachments",
                "logs",
                "sub_units",
            ]
        )
        nullable_fields = set(
            ["docstring", "created_by_user", "created_by_station", "operated_by"]
        )
        serialized = handler(self)
        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            is_nullable_and_explicitly_set = (
                k in nullable_fields
                and (self.__pydantic_fields_set__.intersection({n}))  # pylint: disable=no-member
            )

            if val != UNSET_SENTINEL:
                if (
                    val is not None
                    or k not in optional_fields
                    or is_nullable_and_explicitly_set
                ):
                    m[k] = val

        return m
